import os
import sys
from math import sqrt
from datetime import datetime
from collections import Counter
import random

import numpy as np
from sqlalchemy.sql import func, or_
from sqlalchemy.orm.exc import FlushError
from sqlalchemy.exc import IntegrityError
from sqlalchemy.sql import text
import yaml

import oedipus
from oedipus import config
from oedipus.db import engine, session, Box, MutationStrength
from oedipus import simulation
from oedipus import create_boxes

def boxes_in_generation(run_id, generation):
    """Count number of materials in a generation.

    Args:
        run_id (str): identification string for run.
        generation (int): iteration in overall bin-mutate-simulate rountine.

    Returns:

    """
    return session.query(Box).filter(
        Box.run_id == run_id,
        Box.generation == generation
    ).count()

def last_generation(run_id):
    """Finds latest generation present in database.

    Args:
        run_id (str): identification string for run.

    Returns:
        Last generation(int) to be included in database.

    """
    return session.query(func.max(Box.generation)).filter(
        Box.run_id == run_id,
    )[0][0]

def calc_bin(value, bound_min, bound_max, bins):
    """Find bin in parameter range.

    Args:
        value (float): some value, the result of a simulation.
        bound_min (float): lower limit, defining the parameter-space.
        bound_max (float): upper limit, defining the parameter-space.
        bins (int): number of bins used to subdivide parameter-space.

    Returns:
        Bin(int) corresponding to the input-value.

    """
    step = (bound_max - bound_min) / bins
    assigned_bin = (value - bound_min) // step
    assigned_bin = min(assigned_bin, bins-1)
    assigned_bin = max(assigned_bin, 0)
    return int(assigned_bin)

def run_all_simulations(box):
    """
    Args:
        box (sqlalchemy.orm.query.Query): material to be analyzed.

    """
    results = simulation.alpha.run(box)
    box.update_from_dict(results)
    box.alpha_bin = calc_bin(box.alpha, 0., 1., config['number_of_convergence_bins'])

    results = simulation.beta.run(box)
    box.update_from_dict(results)
    box.beta_bin = calc_bin(box.beta, 0., 1., config['number_of_convergence_bins'])

def get_all_parent_ids(run_id, generation):
    return [e[0] for e in session.query(Box.parent_id) \
            .filter(Box.run_id == run_id, Box.generation == generation) \
            .distinct() if e[0] != None]

def calculate_percent_children_in_bin(run_id, generation, bin_coordinate):
    """Find the fraction of children generated by all parents from a particular
    bin who also belong in the same bin as their parent.

    Args:
        run_id (str): run identification string.
        generation (int): interation in overall process.
        bin (list int): 

    Returns:
        Fraction of children in the same bin as their parent for all parents in
        a particular bin.
    """
    sql = text("""
        select
            m.alpha_bin,
            m.beta_bin,
            (
                m.alpha_bin = p.alpha_bin and
                m.beta_bin = p.beta_bin
            ) as in_bin
        from boxes m
        join boxes p on (m.parent_id = p.id)
        where m.generation = :gen
            and m.run_id = :run_id
            and p.alpha_bin = :alpha_bin
            and p.beta_bin = :beta_bin
        """)

    rows = engine.connect().execute(
        sql,
        gen=generation,
        run_id=run_id,
        alpha_bin=bin_coordinate[0],
        beta_bin=bin_coordinate[1]
    ).fetchall()

    return len([ r for r in rows if r.in_bin ]) / len(rows)

def calculate_mutation_strength(run_id, generation, mutation_strength_bin):
    """Query mutation_strength for bin and adjust as necessary.

    Args:
        run_id (str): identification string for run.
        generation (int): iteration in bin-mutate-simulate routine.
        parent (sqlalchemy.orm.query.Query): parent-material corresponding to
            the bin being queried.

    Returns:
        mutation_strength.strength (float): mutation strength to be used for
        parents in the bin being queried. If the fraction of children from
        previous generation which populate the SAME bin as their parent is LESS
        THAN 10% then the mutation strength is REDUCED BY 5%. If the fraction
        of these children populating the SAME bin as their parent is GREATER
        THAN 50% then the mutation strength is INCREASED BY 5%.

    """
    mutation_strength_key = [run_id, generation] + mutation_strength_bin
    mutation_strength = session.query(MutationStrength).get(mutation_strength_key)

    if mutation_strength:
        print("Mutation strength already calculated for this bin and generation.")
    else:
        print("Calculating mutation strength...")
        mutation_strength = MutationStrength.get_prior(*mutation_strength_key).clone()
        mutation_strength.generation = generation

        try:
            fraction_in_parent_bin = calculate_percent_children_in_bin(run_id, generation, mutation_strength_bin)
            if fraction_in_parent_bin < 0.1 and mutation_strength.strength - 0.05 > 0:
                mutation_strength.strength -= 0.05
            elif fraction_in_parent_bin > 0.5 and mutation_strength.strength + 0.05 < 1:
                mutation_strength.strength += 0.05
        except ZeroDivisionError:
            print("No prior generation materials in this bin with children.")

        try:
            session.add(mutation_strength)
            session.commit()
        except (FlushError, IntegrityError) as e:
            print("Somebody beat us to saving a row with this generation. That's ok!")
            session.rollback()
            # it's ok b/c this calculation should always yield the exact same result!
    sys.stdout.flush()
    return mutation_strength.strength

def evaluate_convergence(run_id, generation):
    '''Determines convergence by calculating variance of bin-counts.
    
    Args:
        run_id (str): identification string for run.
        generation (int): iteration in bin-mutate-simulate routine.

    Returns:
        bool: True if variance is less than or equal to cutt-off criteria (so
            method will continue running).
    '''
    query_group = [Box.alpha_bin, Box.beta_bin]

    bin_counts = session \
        .query(func.count(Box.id)) \
        .filter(
            Box.run_id == run_id, Box.generation < generation,
            Box.generation_index < config['children_per_generation']
        ) \
        .group_by(*query_group).all()
    bin_counts = [i[0] for i in bin_counts]    # convert SQLAlchemy result to list
    variance = sqrt( sum([(i - (sum(bin_counts) / len(bin_counts)))**2 for i in bin_counts]) / len(bin_counts))
    print('\nCONVERGENCE:\t%s\n' % variance)
    sys.stdout.flush()
    return variance <= config['convergence_cutoff_criteria']

def print_block(string):
    print('{0}\n{1}\n{0}'.format('=' * 80, string))

def worker_run_loop(run_id):
    """
    Args:
        run_id (str): identification string for run.

    """
    gen = last_generation(run_id) or 0

    converged = False
    while not converged:
        print_block('GENERATION {}'.format(gen))
        size_of_generation = config['children_per_generation']

        while boxes_in_generation(run_id, gen) < size_of_generation:
            if gen == 0 or config['mutation_scheme'] == 'random':
                print("writing new seed...")
                box = create_boxes.generate.new_box(run_id, gen)
            
            else:
                print("mutating materials...")
                box = create_boxes.mutate.new_box(run_id, gen)

            run_all_simulations(box)
            session.add(box)
            session.commit()

            box.generation_index = box.calculate_generation_index()
            if box.generation_index < config['children_per_generation']:
                print_block('ADDING MATERIAL {}'.format(box.uuid))
                session.add(box)

            # calculate mutation strengths for all bins
            if config['mutation_scheme'] == 'adaptive':
                if box.generation_index == config['children_per_generation'] - 1 and gen > 0:
                    parent_ids = get_all_parent_ids(run_id, gen)
                    print_block('CALCULATING MUTATION STRENGTHS')
                    ms_bins = []
                    for parent_id in parent_ids:
                        parent_bin = session.query(Box).get(parent_id).bin
                        if parent_bin not in ms_bins:
                            print('Calculating bin-mutation-strength for bin : {0}' \
                                    .format(parent_bin))
                            calculate_mutation_strength(run_id, gen + 1, parent_bin)
                        ms_bins.append(parent_bin)
            else:
                # delete excess rows
                # session.delete(material)
                pass
            session.commit()
            sys.stdout.flush()
        gen += 1
        converged = evaluate_convergence(run_id, gen)
