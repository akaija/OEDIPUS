import sys
from random import random
from math import sqrt

import numpy as np
from sqlalchemy.sql import text
from sqlalchemy import func

from oedipus.db import engine, session, Box, MutationStrength

def get_all_parent_ids(run_id, generation):
    return [e[0] for e in session.query(Box.parent_id) \
            .filter(Box.run_id == run_id, Box.generation == generation) \
            .distinct() if e[0] != None]

def calculate_percent_children_in_bin(run_id, generation, bin_coordinate):
    """Find the fraction of children generated by all parents from a particular
    bin who also belong in the same bin as their parent.

    Args:
        run_id (str): run identification string.
        generation (int): interation in overall process.
        bin (list int): 

    Returns:
        Fraction of children in the same bin as their parent for all parents in
        a particular bin.
    """
    sql = text("""
        select
            m.alpha_bin,
            m.beta_bin,
            (
                m.alpha_bin = p.alpha_bin and
                m.beta_bin = p.beta_bin
            ) as in_bin
        from boxes m
        join boxes p on (m.parent_id = p.id)
        where m.generation = :gen
            and m.run_id = :run_id
            and p.alpha_bin = :alpha_bin
            and p.beta_bin = :beta_bin
        """)

    rows = engine.connect().execute(
        sql,
        gen=generation,
        run_id=run_id,
        alpha_bin=bin_coordinate[0],
        beta_bin=bin_coordinate[1]
    ).fetchall()

    return len([ r for r in rows if r.in_bin ]) / len(rows)

def calculate_mutation_strength(run_id, generation, mutation_strength_bin, initial_mutation_strength):
    """Query mutation_strength for bin and adjust as necessary.

    Args:
        run_id (str): identification string for run.
        generation (int): iteration in bin-mutate-simulate routine.
        parent (sqlalchemy.orm.query.Query): parent-material corresponding to
            the bin being queried.

    Returns:
        mutation_strength.strength (float): mutation strength to be used for
        parents in the bin being queried. If the fraction of children from
        previous generation which populate the SAME bin as their parent is LESS
        THAN 10% then the mutation strength is REDUCED BY 5%. If the fraction
        of these children populating the SAME bin as their parent is GREATER
        THAN 50% then the mutation strength is INCREASED BY 5%.

    """
    mutation_strength_key = [run_id, generation, *mutation_strength_bin]
    mutation_strength = session.query(MutationStrength).get(mutation_strength_key)
    mutation_strength_key.append(initial_mutation_strength)

    if mutation_strength:
        pass
    else:
        mutation_strength = MutationStrength.get_prior(*mutation_strength_key).clone()
        mutation_strength.generation = generation

        try:
            fraction_in_parent_bin = calculate_percent_children_in_bin(run_id, generation, mutation_strength_bin)
            if fraction_in_parent_bin < 0.1 and mutation_strength.strength - 0.05 > 0:
                mutation_strength.strength -= 0.05
            elif fraction_in_parent_bin > 0.5 and mutation_strength.strength + 0.05 < 1:
                mutation_strength.strength += 0.05
        except ZeroDivisionError:
            pass

        try:
            session.add(mutation_strength)
            session.commit()
        except (FlushError, IntegrityError) as e:
            print("Somebody beat us to saving a row with this generation. That's ok!")
            session.rollback()
            # it's ok b/c this calculation should always yield the exact same result!
    sys.stdout.flush()
    return mutation_strength.strength

def calculate_all_mutation_strengths(run_id, gen, initial_mutation_strength):
    parent_ids = get_all_parent_ids(run_id, gen)
    ms_bins = []
    for parent_id in parent_ids:
        parent_bin = session.query(Box).get(parent_id).bin
        if parent_bin not in ms_bins:
            calculate_mutation_strength(run_id, gen + 1, parent_bin,
                    initial_mutation_strength)
        ms_bins.append(parent_bin)

def smallest_bin_selection(run_id, max_generation, children_per_generation):
    """Use bin-counts to preferentially select a list of 'rare' parents.

    Args:
        run_id (str): identification string for run.
        max_generation (int): latest generation to include when counting number
            of materials ub each bin.
        generation_limit (int): number of materials to query in each generation
            (as materials are added to database they are assigned an index
            within the generation to bound the number of materials in each
            generation).

    Returns:
        The material id(int) corresponding to some parent-material selected
        from database with a bias favoring materials in bins with the lowest
        counts.

    """
    queries = [Box.alpha_bin, Box.beta_bin]

    # Each bin is counted...
    bins_and_counts = session \
        .query(func.count(Box.id), Box.alpha_bin, Box.beta_bin) \
        .filter(
            Box.run_id == run_id,
            Box.generation <= max_generation,
        ) \
        .group_by(Box.alpha_bin, Box.beta_bin).all()[1:]
    bins = []
    for i in bins_and_counts:
        some_bin = {}
        for j in range(len(queries)):
            some_bin[queries[j]] = i[j + 1]
        bins.append(some_bin)
    total = sum([i[0] for i in bins_and_counts])
    # ...then assigned a weight.
    weights = [ total / float(i[0]) for i in bins_and_counts ]
    normalized_weights = [ weight / sum(weights) for weight in weights ]
    parent_bin = np.random.choice(bins, p = normalized_weights)
    parent_queries = [i == parent_bin[i] for i in queries]
    parent_query = session \
        .query(Box.id) \
        .filter(
            Box.run_id == run_id,
            *parent_queries,
            Box.generation <= max_generation,).all()
    potential_parents = [i[0] for i in parent_query]
    return int(np.random.choice(potential_parents))

def center_of_mass_selection(run_id, max_generation, children_per_generation):
    filters = [Box.run_id == run_id, Box.generation <= max_generation]
    ids = [e[0] for e in session.query(Box.id).filter(*filters).all()]
    alpha = [e[0] for e in session.query(Box.alpha).filter(*filters).all()]
    beta = [e[0] for e in session.query(Box.beta).filter(*filters).all()]
    alpha_bar = sum(alpha) / len(alpha)
    beta_bar = sum(beta) / len(beta)
    distance = [sqrt((alpha[e] - alpha_bar) ** 2 + (beta[e] - beta_bar) ** 2) for e in range(len(alpha))]
    weights = [e / sum(distance) for e in distance]
    normalized_weights = [e / sum(weights) for e in weights]
    return int(np.random.choice(ids, p = normalized_weights))

def perturb_length(x, ms):
    dx = ms * (random() - x)
    return x + dx

def mutate_box(parent_box, mutation_strength, generation):
    """    
    Args:

    Returns:

    """
    ########################################################################
    # create box
    child_box = Box(parent_box.run_id)
    child_box.parent_id = parent_box.id
    child_box.generation = generation

    ########################################################################
    # perturb side lengths
    child_box.x = perturb_length(parent_box.x, mutation_strength)
    child_box.y = perturb_length(parent_box.y, mutation_strength)
    child_box.z = perturb_length(parent_box.z, mutation_strength)

    return child_box

def new_boxes(run_id, gen, children_per_generation, config):
    # calculate mutation strengths, if adaptive
    if 'adaptive' in config['mutation_scheme'] and gen > 1:
        calculate_all_mutation_strengths(run_id, gen - 1,
                config['initial_mutation_strength'])

    boxes = []
    for i in range(children_per_generation):
        if config['selection_scheme'] == 'smallest_bin':
            parent_id = smallest_bin_selection(run_id, gen - 1,
                children_per_generation)
        elif config['selection_scheme'] == 'center_of_mass':
            parent_id = center_of_mass_selection(run_id, gen - 1,
                children_per_generation)
        elif config['selection_scheme'] == 'hybrid':
            select = random()
            if select < 0.5:
                parent_id = smallest_bin_selection(run_id, gen - 1,
                    children_per_generation)
            else:
                parent_id = center_of_mass_selection(run_id, gen - 1,
                    children_per_generation)
        else:
            print('REVISE CONFIG, UNSUPPORTED SELECTION SCHEME.')
        parent_box = session.query(Box).get(parent_id)
    
        if config['mutation_scheme'] == 'flat':
            mutation_strength = config['initial_mutation_strength']
        elif config['mutation_scheme'] == 'hybrid':
            mutation_strength = np.random.choice([1., config['initial_mutation_strength']])
        elif config['mutation_scheme'] == 'adaptive':
            mutation_strength_key = [run_id, gen, *parent_box.bin,
                    config['initial_mutation_strength']]
            mutation_strength = MutationStrength.get_prior(*mutation_strength_key).clone().strength
        elif config['mutation_scheme'] == 'hybrid_adaptive':
            mutation_strength_key = [run_id, gen, *parent_box.bin,
                    config['initial_mutation_strength']]
            ms = MutationStrength.get_prior(*mutation_strength_key).clone().strength
            mutation_strength = np.random.choice([1., ms])
        else:
            print("REVISE CONFIG FILE, UNSUPPORTED MUTATION SCHEME.")
    
        # mutate material
        box = mutate_box(parent_box, mutation_strength, gen)
        boxes.append(box)
    return boxes
